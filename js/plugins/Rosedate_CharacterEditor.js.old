/*:============================================================================
*
* @target MZ
*
* @author Chaucer
*
* @plugindesc | Character Editor Scene : Version - 1.0.0 | Add the character editor scene.
*
* @url http://rosedale-studios.com
*
* @help
* ╔════════════════════════════════════╗
* ║ ()()                                                              ()() ║
* ║ (^.^)                    - Rosedale Studios -                    (^.^) ║
* ║c(")(")                                                          (")(")ↄ║
* ╚════════════════════════════════════╝

*============================================================================
*  Requirements :
*============================================================================

*============================================================================
*  Instructions :
*============================================================================


*============================================================================
*  Terms Of Use :
*============================================================================

*  This Plugin may be used commercially, or non commercially. This plugin may
* be extended upon, and or shared freely as long as credit is given to it's
* author(s). This plugin may NOT be sold, or plagiarized.

*============================================================================
*  Version History :
*============================================================================

*  ● Version : 1.0.0
*  ● Date : 18/01/2024
*    ★ Release.

*============================================================================
*  Contact Me :
*============================================================================

*  If you have questions, about this plugin, or commissioning me, or have
*  a bug to report, please feel free to contact me by any of the below
*  methods.

*  website : https://www.rosedale-studios.com
*  rmw : https://forums.rpgmakerweb.com/index.php?members/chaucer.44456
*  youtube : https://www.youtube.com/channel/UCYA4VU5izmbQvnjMINssshQ/videos
*  email : chaucer(at)rosedale-studios(dot)com
*  discord : https://discord.gg/nexQGb65uP

*============================================================================*/

//=============================================================================
  var Imported = Imported || {};
  Imported['Character Editor Scene'.toUpperCase()] = true;
//=============================================================================
  var Chaucer = Chaucer || {};
  Chaucer.characterEdit = {};
//=============================================================================

//=============================================================================
// Scene_CharacterEditor :
//=============================================================================

//=============================================================================
class Scene_CharacterEditor extends Scene_Base
{ // Scene_CharacterEditor

//=============================================================================
  constructor()
  { // Called on object creation.
//=============================================================================

    super();

  }

//=============================================================================
  create()
  { // create all elements of the scene.
//=============================================================================


    this.createEditor();
    this.createDirectionContainer();
    this.createMotionDataContainer();
    this.createAnimationContainer();
    this.createFramesContainer();
    // this.createTopContainer();

  }

//=============================================================================
  createEditor()
  { // create the editor sprite.
//=============================================================================

    this._editorSprite = new Sprite_Editor();
    this._editorSprite.x = Graphics.width / 2;
    this._editorSprite.y = Graphics.height / 2 + Graphics.height / 4;
    this.addChild( this._editorSprite );

  }

//=============================================================================
  createDirectionContainer()
  { // create a container for the direction buttons and character sprite.
//=============================================================================

    this._directionsContainer = new DirectionContainer();
    this.addChild( this._directionsContainer );

  }

//=============================================================================
  createMotionDataContainer()
  { // create a container for the motion data.
//=============================================================================

    const x = this._directionsContainer.x;
    const y = this._directionsContainer.y + this._directionsContainer.height;
    const width = this._directionsContainer.width;
    const height = Graphics.height - y;
    const rect = new Rectangle( x, y, width, height );

    this._motionDataContainer = new MotionDataContainer( rect );
    this.addChild( this._motionDataContainer );

  }

//=============================================================================
  createAnimationContainer()
  { // create the container for selecting animations.
//=============================================================================

    const height = Graphics.height;
    const width = Graphics.width / 4;
    const x = Graphics.width - width;
    const y = Graphics.height - height;

    const rect = new Rectangle( x, y, width, height );
    this._animationContainer = new AnimationContainer( rect );
    this.addChild( this._animationContainer );

  }

//=============================================================================
  createFramesContainer()
  { // create container that will display the available frames in the animation.
//=============================================================================

    const height = Graphics.height / 4;
    const x = this._motionDataContainer.x + this._motionDataContainer.width;
    const y = Graphics.height - height;
    const width = Graphics.width - x - this._animationContainer.width;

    const rect = new Rectangle( x, y, width, height );
    this._frameContainer = new FrameContainer( rect );

    this.addChild( this._frameContainer );

  }

//=============================================================================
  update()
  { // update the scene.
//=============================================================================

    super.update();
    this.updateMiniCharacter();
    this.updateFrameContianer();

  }

//=============================================================================
  convertToArray( object )
  { // convert an object to an array.
//=============================================================================

    let array =  [];

    const keys = Object.keys( object );

    for ( let i = 0, l = keys.length; i < l; i++ ) {
      const entry = object[keys[i]];
      if ( !entry ) continue;
      entry.name = entry.name || keys[i];
      array.push( entry );
    };

    return array;

  }

//=============================================================================
  updateMiniCharacter()
  { // update the mini character in the direction field.
//=============================================================================

    const character = this._directionsContainer._character;
    const motionData = this._motionDataContainer._listField.item();

    if ( motionData && motionData.motions != character._motions ) {
      if ( motionData.motions != character._motions2 ) {
        character.setMotions( motionData.motions );
        const data = this.convertToArray( motionData.motions )
        this._animationContainer._animationDropDown.data = data;
      }
    }

    character.update();

  }

//=============================================================================
  updateFrameContianer()
  { // update the frame container.
//=============================================================================

    const animation = this._animationContainer._animationDropDown.item();
    const direction = this._directionsContainer._direction;
    const frameContainer = this._frameContainer;
    const editor = this._editorSprite;
    if ( frameContainer._animation != animation ) {
      frameContainer.setAnimation( animation );
      editor.setFrameData( animation );
    }
    if ( direction != frameContainer._direction ) {
      frameContainer.setDirection( direction );
      editor.setDirection( direction );
    }
    if ( editor._index != frameContainer.index ) {
      editor.setIndex( frameContainer.index );
    }

  }

}

//=============================================================================
// Game_CharacterMini :
//=============================================================================

//=============================================================================
class Game_CharacterMini extends Game_Character
{ // Game_CharacterMini

//=============================================================================
  constructor()
  { // Called on object creation.
//=============================================================================

    super();

  }

//=============================================================================
  scrolledX()
  { // return the scrolled x.
//=============================================================================

    return 0;

  }

//=============================================================================
  scrolledY()
  { // return the scrolled y.
//=============================================================================

    return 0;

  }

//=============================================================================
  screenX()
  { // return the screen x position.
//=============================================================================

    return 160;

  }

//=============================================================================
  screenY()
  { // return the screen y position.
//=============================================================================

    const sprite = SceneManager._scene._directionsContainer._characterSprite;
    return 160 + 34 + sprite.height / 2;

  }

}

//=============================================================================
window.Game_CharacterMini = Game_CharacterMini;
//=============================================================================

//=============================================================================
// DirectionContainer :
//=============================================================================

//=============================================================================
class DirectionContainer extends ContainerField
{ // DirectionContainer

//=============================================================================
  constructor( x, y )
  { // Called on object creation.
//=============================================================================

    const width = Graphics.width / 4 + 1;
    const height = width + 34;
    const rect = new Rectangle( x, y, width, height );

    super( rect );
    this._usedir8 = true;
    this._motionData = 0;
    this._direction = 2;
    this._motion = 'idle';
    this.set4Dir( true );

    // TODO: need another for projectiles.
  }
// TODO: I need to create rectangle data that is TIED to the motion data!
// then draw sprites for cooresponding data.

//=============================================================================
  createElements()
  { // create all element buttons.
//=============================================================================

    this.createTopButtons();

    this.createUpLeftButton();
    this.createUpButton();
    this.createUpRightButton();

    this.createLeftButton();
    this.createMidButton();
    this.createRightButton();

    this.createDownLeftButton();
    this.createDownButton();
    this.createDownRightButton();

  }

//=============================================================================
  get defaults()
  { // return the default changes.
//=============================================================================

    return {
      backgroundColor: '#4a505b',
      hoverColor: '#adafb3'
    };

  }


//=============================================================================
  setDirection( d )
  { // set the direction.
//=============================================================================

    this._direction = d;
    this._character.setDirection( d );

  }

//=============================================================================
  createTopButtons()
  { // create the top buttons.
//=============================================================================

    this.createButton4Dir();
    this.createButton8Dir();
    this.createButtonPlatformer();

  }

//=============================================================================
  createButton4Dir()
  { // create the 4 directional button( 4 rows ).
//=============================================================================

    const width = ( ( this.width - 4 ) / 3 );
    const height = 32;
    const x = width * 0 + 3;
    const y = 3;

    this._button4Dir = new ButtonField( width, height, '4 Dir' );
    this._button4Dir.position.set( x, y );

    this.addChild( this._button4Dir );

    this._button4Dir.setClickHandler( this.set4Dir.bind( this ) );

  }

//=============================================================================
  set4Dir()
  { // set the sprite to use 4 directions only.
//=============================================================================

    this._usedir8 = false;
    this._upButton.visible = true;
    this._downButton.visible = true;
    this._upLeftButton.visible = false;
    this._upRightButton.visible = false;
    this._downLeftButton.visible = false;
    this._downRightButton.visible = false;

    this._button2Dir.backgroundColor = "#d97fc9";
    this._button4Dir.backgroundColor = "#457fc9";
    this._button8Dir.backgroundColor = "#d97fc9";
    this._button2Dir.hoverColor = "#db8f99";
    this._button4Dir.hoverColor = "#5287cc";
    this._button8Dir.hoverColor = "#db8f99";

    this.setDirection( 2 );

  }

//=============================================================================
  createButton8Dir()
  { // create button for 8 directional sprites( 8 rows ).
//=============================================================================

    const width = ( ( this.width - 4 ) / 3 );
    const height = 32;
    const x = ( this.width - 4 ) / 3 * 1 + 3;
    const y = 3;

    this._button8Dir = new ButtonField( width, height, '8 Dir' );
    this._button8Dir.position.set( x, y );

    this.addChild( this._button8Dir );

    this._button8Dir.setClickHandler( this.set8Dir.bind( this ) );

  }

//=============================================================================
  set8Dir()
  { // set the sprite to use 4 directions only.
//=============================================================================

    this._usedir8 = true;
    this._upButton.visible = true;
    this._downButton.visible = true;
    this._upLeftButton.visible = true;
    this._upRightButton.visible = true;
    this._downLeftButton.visible = true;
    this._downRightButton.visible = true;

    this._button2Dir.backgroundColor = "#d97fc9"
    this._button4Dir.backgroundColor = "#d97fc9"
    this._button8Dir.backgroundColor = "#457fc9"
    this._button2Dir.hoverColor = "#db8f99";
    this._button4Dir.hoverColor = "#db8f99";
    this._button8Dir.hoverColor = "#5287cc";

    this.setDirection( 2 );

  }

//=============================================================================
  createButtonPlatformer()
  { // create a button for platformer sprites( single row ).
//=============================================================================

    const width = ( ( this.width - 4 ) / 3 );
    const height = 32;
    const x = ( this.width - 4 ) / 3 * 2 + 3;
    const y = 3;

    this._button2Dir = new ButtonField( width, height, 'Platformer' );
    this._button2Dir.position.set( x, y );

    this.addChild( this._button2Dir );

    this._button2Dir.setClickHandler( this.setPlatformer.bind( this ) );

  }

//=============================================================================
  setPlatformer()
  { // set the sprite to use 4 directions only.
//=============================================================================

    this._usedir8 = 'platformer';
    this._upButton.visible = false;
    this._downButton.visible = false;
    this._upLeftButton.visible = false;
    this._upRightButton.visible = false;
    this._downLeftButton.visible = false;
    this._downRightButton.visible = false;

    this._button2Dir.backgroundColor = "#457fc9"
    this._button4Dir.backgroundColor = "#d97fc9"
    this._button8Dir.backgroundColor = "#d97fc9"
    this._button2Dir.hoverColor = "#5287cc";
    this._button4Dir.hoverColor = "#db8f99";
    this._button8Dir.hoverColor = "#db8f99";

    this.setDirection( 6 );

  }

//=============================================================================
  createUpLeftButton()
  { // create a button that displays up left arrow.
//=============================================================================

    const x = 2;
    const y = 34 + 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬉';
    this._upLeftButton = new ButtonField( width, height, text, this.defaults );
    this._upLeftButton.position.set( x, y );
    this._upLeftButton.fontSize = 52;
    this.addElement( this._upLeftButton );

    this._upLeftButton.setClickHandler( function() {
      this.setDirection( 7 )
    }.bind( this ) );

  }

//=============================================================================
  createUpButton()
  { // create the up button.
//=============================================================================

    const x = Math.floor( 1 + this.width / 3 );
    const y = 34 + 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬆';
    this._upButton = new ButtonField( width, height, text, this.defaults );
    this._upButton.position.set( x, y );
    this._upButton.fontSize = 52;
    this.addElement( this._upButton );

    this._upButton.setClickHandler( function() {
      this.setDirection( 8 )
    }.bind( this ) );

  }

//=============================================================================
  createUpRightButton()
  { // create the up right button.
//=============================================================================

    const x = Math.floor( 0 + this.width / 3 * 2 );
    const y = 34 + 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬈';
    this._upRightButton = new ButtonField( width, height, text, this.defaults );
    this._upRightButton.position.set( x, y );
    this._upRightButton.fontSize = 52;
    this.addElement( this._upRightButton );

    this._upRightButton.setClickHandler( function() {
      this.setDirection( 9 )
    }.bind( this ) );

  }

//=============================================================================
  createLeftButton()
  { // create a button that displays left arrow.
//=============================================================================

    const x = 2;
    const y = 34 + 1 + Math.floor( this.width / 3 );
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬅';
    this._leftButton = new ButtonField( width, height, text, this.defaults );
    this._leftButton.position.set( x, y );
    this._leftButton.fontSize = 52;
    this.addElement( this._leftButton );

    this._leftButton.setClickHandler( function() {
      this.setDirection( 4 )
    }.bind( this ) );

  }

//=============================================================================
  createMidButton()
  { // create the center button.
//=============================================================================

    this._character = new Game_CharacterMini();
    this._character.setStepAnime( true );
    this._characterSprite = new Sprite_Character( this._character );
    this.addChild( this._characterSprite );

  }

//=============================================================================
  createRightButton()
  { // create the right button.
//=============================================================================

    const x = Math.floor( 0 + this.width / 3 * 2 );
    const y = 34 + 1 + Math.floor( this.width / 3 );
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '➡';
    this._rightButton = new ButtonField( width, height, text, this.defaults );
    this._rightButton.position.set( x, y );
    this._rightButton.fontSize = 52;
    this.addElement( this._rightButton );

    this._rightButton.setClickHandler( function() {
      this.setDirection( 6 )
    }.bind( this ) );

  }

//=============================================================================
  createDownLeftButton()
  { // create a button that displays down left arrow.
//=============================================================================

    const x = 2;
    const y = 34 + 0 + Math.floor( this.width / 3 ) * 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬋';
    this._downLeftButton = new ButtonField( width, height, text, this.defaults );
    this._downLeftButton.position.set( x, y );
    this._downLeftButton.fontSize = 52;
    this.addElement( this._downLeftButton );

    this._downLeftButton.setClickHandler( function() {
      this.setDirection( 1 )
    }.bind( this ) );

  }

//=============================================================================
  createDownButton()
  { // create the up button.
//=============================================================================

    const x = Math.floor( 1 + this.width / 3 );
    const y = 34 + 0 + Math.floor( this.width / 3 ) * 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬇';
    this._downButton = new ButtonField( width, height, text, this.defaults );
    this._downButton.position.set( x, y );
    this._downButton.fontSize = 52;
    this.addElement( this._downButton );

    this._downButton.setClickHandler( function() {
      this.setDirection( 2 )
    }.bind( this ) );

  }

//=============================================================================
  createDownRightButton()
  { // create the up right button.
//=============================================================================

    const x = Math.floor( 0 + this.width / 3 * 2 );
    const y = 34 + 0 + Math.floor( this.width / 3 ) * 2;
    const width = Math.floor( this.width / 3 - 2 );
    const height = width;
    const text = '⬊';
    this._downRightButton = new ButtonField( width, height, text, this.defaults );
    this._downRightButton.position.set( x, y );
    this._downRightButton.fontSize = 52;
    this.addElement( this._downRightButton );

    this._downRightButton.setClickHandler( function() {
      this.setDirection( 3 );
    }.bind( this ) );

  }

}

//=============================================================================
window.DirectionContainer = DirectionContainer;
//=============================================================================

//=============================================================================
class MotionDataContainer extends ContainerField
{ // MotionDataContainer

//=============================================================================
  constructor( rect )
  { // Called on object creation.
//=============================================================================

    super( rect );
    const motions = this.fetchProjectMotionData();
    this.createMotionDataField( motions );
    this._motionData = null;

  }

//=============================================================================
  fetchProjectMotionData()
  { // fetch the motion data from the current project.
//=============================================================================

    const fs = require( 'fs' );
    const path = require( 'path' );
    const base = $gameTemp._project.directory;
    const plugin = 'plugins.js';
    const dir = path.join( base, 'js', plugin )
    // let oldPlugins = $plugins;
    let string = fs.readFileSync( dir, { encoding:'utf8', flag:'r' } );
    string = string.replace( 'var $plugins =\n', '' );
    const data = this.findMotionData( eval( string ) );

    return data;

  }

//=============================================================================
  findMotionData( plugins )
  { // return motion data from list of plugins.
//=============================================================================

    const identifier =  /(Character Actions) : Version - (\d+.\d+.\d+)/;
    let plugin = null;
    let data = [];

    for ( let i = 0, l = plugins.length; i < l; i++ ) {
      if ( plugins[i].description.match( identifier ) ) {
        plugin = plugins[i];
        break;
      }
    };

    if ( plugin ) {
      let motions = Chaucer.parse( plugin.parameters ).motionData;

      for ( let i = 0, l = motions.length; i < l; i++ ) {
        const customAnimations = motions[i].customAnimations;
        const name = motions[i].name;

        delete motions[i].name;
        delete motions[i].customAnimations;
        delete motions[i].conditionalMotionData;


        for ( let j = 0, l2 = customAnimations.length; j < l2; j++ ) {
          const name = customAnimations[j].name;
          motions[i][name] = customAnimations[j];
        };

        data.push( { name, motions: motions[i] } );

      };

    }

    return data;

  }

//=============================================================================
  createMotionDataField( motions )
  { // create a field for motion data.
//=============================================================================

    this._listField = new ListField( this.width, 14, motions );
    this.addElement( this._listField );

  }

}

//=============================================================================
window.MotionDataContainer = MotionDataContainer;
//=============================================================================

//=============================================================================
// AnimationContainer :
//=============================================================================

//=============================================================================
class AnimationContainer extends ContainerField
{ // AnimationContainer

//=============================================================================
  constructor( rect )
  { // Called on object creation.
//=============================================================================

    super( rect );

  }

//=============================================================================
  createElements()
  { // create all elements of the container.
//=============================================================================

    this.createAnimationSettings();
    this.createAnimationDropDown();
    this.createAnimationLabel();

  }

//=============================================================================
  createAnimationLabel()
  { // create a label that says animation.
//=============================================================================

    this._animationLabel = new LabelField( 'Current Animation' );
    this._animationLabel.align = 'center';
    this._animationLabel.x = this.width / 2;
    this._animationLabel.y = 10;
    this.addElement( this._animationLabel );

  }

//=============================================================================
  createAnimationDropDown()
  { // create the drop down for selectng animations.
//=============================================================================

    const data = [];
    const width = this.width - 20;
    this._animationDropDown = new DropDownField( width, data );
    this._animationDropDown.x = ( this.width - width ) / 2;
    this._animationDropDown.y = 32 + 5;
    this.addElement( this._animationDropDown );

    this._animationDropDown.setOkHandler( this.onAnimationOk.bind( this ) );

  }

//=============================================================================
  onAnimationOk()
  { // when choosing an animation from the list.
//=============================================================================

    const { index, data } = this._animationDropDown;
    this._animation = data[index] ? data[index] : null;
    // TODO: refresh settings whatever they may be

  }

//=============================================================================
  createAnimationSettings()
  { // create the settings for the animation.
//=============================================================================

    this.createSettingsLabel();

  }

//=============================================================================
  createSettingsLabel()
  { // create a label to indicate the animation settings.
//=============================================================================

    this._settingsLabel = new LabelField( 'Animation Settings' );
    this._settingsLabel.align = 'center';
    this._settingsLabel.x = this.width / 2;
    this._settingsLabel.y = 32 * 2 + 10;
    this.addElement( this._settingsLabel );

  }

}

//=============================================================================
window.AnimationContainer = AnimationContainer;
//=============================================================================

//=============================================================================
// FrameContainer :
//=============================================================================

//=============================================================================
class FrameContainer extends ContainerField
{ // FrameContainer

//=============================================================================
  constructor( rect )
  { // Called on object creation.
//=============================================================================

    super( rect );

  }

//=============================================================================
  get label()
  { // return the current text.
//=============================================================================

    return this._frameLabel.text;

  }

//=============================================================================
  set label( value )
  { // set the current text.
//=============================================================================

    this._frameLabel.text = value;

  }

//=============================================================================
  get index()
  { // return the current index for the animation.
//=============================================================================

    return this._index;

  }

//=============================================================================
  set index( value )
  { // set the index of the current animation.
//=============================================================================

    this._index = ( value ).mod( this._animation.frames );
    this.refreshPreviousFrame();
    this.refreshCurrentFrame();
    this.refreshNextFrame();

  }

//=============================================================================
  setDirection( direction )
  { // set the direction.
//=============================================================================

    this._direction = direction;
    this.refreshPreviousFrame();
    this.refreshCurrentFrame();
    this.refreshNextFrame();

  }

//=============================================================================
  setAnimation( animation )
  { // set the animation.
//=============================================================================

    this._animation = animation;
    this._index = 0;
    this.refreshLabel();
    this.refreshPreviousFrame();
    this.refreshCurrentFrame();
    this.refreshNextFrame();

  }

//=============================================================================
  refreshLabel()
  { // refresh the current label text.
//=============================================================================

    let text = 'Frames';

    if ( this._animation ) {
      text = `Frame: ${this.index + 1}/${this._animation.frames}`;
    }

    this._frameLabel.text = text;

  }

//=============================================================================
  getFrameFor( src, index )
  { // return the frame for the bitmap.
//=============================================================================

    const d = this._direction - ( ( this._direction || 0 ) >= 5 ? 2 : 1 );
    const w = src.width / this._animation.frames;
    const h = src.height / 8;
    const x = w * index;
    const y = h * d;

    const rect = new Rectangle( x, y, w, h );
    rect.index = index + 1;

    return rect;

  }

//=============================================================================
  refreshPreviousFrame()
  { // refresh the previous frame.
//=============================================================================

    if ( this._animation ) {
      const n = this._animation.frames;
      const index = ( this.index - 1 ).mod( n );
      const filename = this._animation.filename;
      const src = ImageManager.loadCharacter( filename );

      src.addLoadListener( function() {
        this._prevFrame._src = src;
        this._prevFrame._rect = this.getFrameFor( src, index );
        this._prevFrame.refresh();
      }.bind( this ) );


    }

  }

//=============================================================================
  refreshCurrentFrame()
  { // refresh the current frame.
//=============================================================================

    if ( this._animation ) {
      const n = this._animation.frames;
      const index = ( this.index ).mod( n );
      const filename = this._animation.filename;
      const src = ImageManager.loadCharacter( filename );

      src.addLoadListener( function() {
        this._currFrame._src = src;
        this._currFrame._rect = this.getFrameFor( src, index );
        this._currFrame.refresh();
      }.bind( this ) );


    }

  }

//=============================================================================
  refreshNextFrame()
  { // refresh the next frame.
//=============================================================================

    if ( this._animation ) {
      const n = this._animation.frames;
      const index = ( this.index + 1 ).mod( n );
      const filename = this._animation.filename;
      const src = ImageManager.loadCharacter( filename );

      src.addLoadListener( function() {
        this._nextFrame._src = src;
        this._nextFrame._rect = this.getFrameFor( src, index );
        this._nextFrame.refresh();
      }.bind( this ) );


    }

  }

//=============================================================================
  createElements()
  { // create all elements in the container.
//=============================================================================

    this.createFrameLabel();
    this.createLeftArrow();
    this.createRightArrow();
    this.createCurrentFrame();
    this.createPreviousFrame();
    this.createNextFrame();
  }

//=============================================================================
  createFrameLabel()
  { // create a label for the frame data.
//=============================================================================

    const text = 'Frames';

    this._frameLabel = new LabelField( text );
    this._frameLabel.align = 'center';
    this._frameLabel.x = this.width / 2;
    this._frameLabel.y = 10;

    this.addElement( this._frameLabel );

  }

//=============================================================================
  createLeftArrow()
  { // create the left arrow button.
//=============================================================================

    const text = '⬅';
    const width = 32;
    const height = this.height - 32 - 8;
    this._leftArrow = new ButtonField( width, height, text );
    this._leftArrow.position.set( 4, 32 + 4 );

    this.addElement( this._leftArrow );
    this._leftArrow.setClickHandler( this.decreaseIndex.bind( this ) );

  }

//=============================================================================
  decreaseIndex()
  { // decrease the index by 1.
//=============================================================================

    this.index--;

  }

//=============================================================================
  createRightArrow()
  { // create the right arrow button.
//=============================================================================

    const text = '➡';
    const width = 32;
    const height = this.height - 32 - 8;
    this._rightArrow = new ButtonField( width, height, text );
    this._rightArrow.position.set( this.width - width - 4, 32 + 4 );

    this.addElement( this._rightArrow );

    this._rightArrow.setClickHandler( this.increaseIndex.bind( this ) );

  }

//=============================================================================
  increaseIndex()
  { // increase the index by 1.
//=============================================================================

    this.index++;

  }

//=============================================================================
  createCurrentFrame()
  { // create the current frame sprite window.
//=============================================================================

    const text = 'current';
    const height = this.height - 32 - 8;
    const width = height;
    const settings = {
      backgroundColor: '#4a505b',
      hoverColor: '#4a505b',
      clickColor: '#4a505b',
      outlineColor: '#1a1a1a',
      clickOutlineColor: '#1a1a1a'
    };
    this._currFrame = new ButtonField( width, height, text, settings );
    this._currFrame.position.set( Math.floor( ( this.width - width ) / 2 ), 32 + 4 );

    this._currFrame.refreshText = function() {
      const dx = 10;
      const dy = 10;
      const dw = this.width - 20;
      const dh = this.height - 20;
      const src = this._src;
      const rect = this._rect;
      if ( src && rect )  {
        const { x:sx, y:sy, width:sw, height:sh } = rect;
        this.bitmap.paintOpacity = 255;
        this.bitmap.blt( src, sx, sy, sw, sh, dx, dy, dw, dh );

      }
      this.bitmap.paintOpacity = 255;
      this.bitmap.drawRoundedRect( 4, 4, 48, 24, 4, '#393f4a' );
      this.bitmap.drawRoundedRect( 5, 5, 46, 22, 4, '#20252b' );
      if ( rect ) {
        this.bitmap.drawText( rect.index, 5, 5, 46, 22, 'center' );
      }

    }

    this._currFrame.refresh();
    this.addElement( this._currFrame );


  }

//=============================================================================
  createPreviousFrame()
  { // create the previous frame sprite.
//=============================================================================

    const text = '';
    const height = this.height - 32 - 8;
    const width = height;
    const ox = this._leftArrow.x + this._leftArrow.width;
    const x = ( ox + ( this._currFrame.x - ( ox ) - width ) / 2 );
    const settings = {
      backgroundColor: '#4a505b',
      hoverColor: '#4a505b',
      clickColor: '#4a505b',
      outlineColor: '#1a1a1a',
      clickOutlineColor: '#1a1a1a'
    };
    this._prevFrame = new ButtonField( width, height, text, settings );
    this._prevFrame.position.set( Math.floor( x ), 32 + 4 );

    this._prevFrame.refreshText = function() {
      const dx = 10;
      const dy = 10;
      const dw = this.width - 20;
      const dh = this.height - 20;
      const src = this._src;
      const rect = this._rect;
      if ( src && rect )  {
        const { x:sx, y:sy, width:sw, height:sh } = rect;
        this.bitmap.paintOpacity = 100;
        this.bitmap.blt( src, sx, sy, sw, sh, dx, dy, dw, dh );
      }
      this.bitmap.paintOpacity = 255;
      this.bitmap.drawRoundedRect( 4, 4, 48, 24, 4, '#393f4a' );
      this.bitmap.drawRoundedRect( 5, 5, 46, 22, 4, '#20252b' );
      if ( rect ) {
        this.bitmap.paintOpacity = 100;
        this.bitmap.drawText( rect.index, 5, 5, 46, 22, 'center' );
      }

    }

    this._prevFrame.refresh();
    this.addElement( this._prevFrame );

  }

//=============================================================================
  createNextFrame()
  { // create the previous frame sprite.
//=============================================================================

    const text = 'next';
    const height = this.height - 32 - 8;
    const width = height;
    const ox = this._currFrame.x + this._currFrame.width;
    const x = ( ox + ( this._rightArrow.x - ( ox ) - width ) / 2 );
    const settings = {
      backgroundColor: '#4a505b',
      hoverColor: '#4a505b',
      clickColor: '#4a505b',
      outlineColor: '#1a1a1a',
      clickOutlineColor: '#1a1a1a'
    };
    this._nextFrame = new ButtonField( width, height, text, settings );
    this._nextFrame.position.set( Math.floor( x ), 32 + 4 );

    this._nextFrame.refreshText = function() {
      const dx = 10;
      const dy = 10;
      const dw = this.width - 20;
      const dh = this.height - 20;
      const src = this._src;
      const rect = this._rect;
      if ( src && rect )  {
        const { x:sx, y:sy, width:sw, height:sh } = rect;
        this.bitmap.paintOpacity = 100;
        this.bitmap.blt( src, sx, sy, sw, sh, dx, dy, dw, dh );
      }
      this.bitmap.paintOpacity = 255;
      this.bitmap.drawRoundedRect( 4, 4, 48, 24, 4, '#393f4a' );
      this.bitmap.drawRoundedRect( 5, 5, 46, 22, 4, '#20252b' );
      if ( rect ) {
        this.bitmap.paintOpacity = 100;
        this.bitmap.drawText( rect.index, 5, 5, 46, 22, 'center' );
      }

    }

    this._nextFrame.refresh();
    this.addElement( this._nextFrame );

  }

}

//=============================================================================
window.FrameContainer = FrameContainer;
//=============================================================================

//=============================================================================
window.Scene_CharacterEditor = Scene_CharacterEditor;
//=============================================================================

//=============================================================================
// Sprite_Rectangle :
//=============================================================================

//=============================================================================
class Sprite_Rectangle extends Sprite
{ // Sprite_Rectangle

//=============================================================================
  constructor( x, y )
  { // Called on object creation.
//=============================================================================

    super( new Bitmap( 1, 1 ) );
    this._rect = new Rectangle( x, y, 5, 5 );
    this._orgRect = JsonEx.parse( JsonEx.stringify( this._rect ) );
    this._dragging = true;
    this._direction = 3;
    this.refresh();

  }

//=============================================================================
  refresh()
  { // refresh the sprite.
//=============================================================================

    const { x, y, width, height } = this._rect;
    this.bitmap.resize( width, height );
    this.position.set( x, y );
    this.height = height;
    this.width = width;

    this.bitmap.clear();

    this.drawCenter();
    this.drawTop();
    this.drawLeft();
    this.drawRight();
    this.drawBottom();

  }

//=============================================================================
  drawCenter()
  { // draw the center of the rectangle.
//=============================================================================

    this.bitmap.paintOpacity = 50;

    const color = [5].includes( this._direction ) ? '#ff6600' : '#00FF00';
    const { x, y, width, height } = this._rect;
    this.bitmap.fillRect( 0, 0, width, height, color );
    this.bitmap.paintOpacity = 255;

  }

//=============================================================================
  drawTop()
  { // draw the top line.
//=============================================================================

    const x1 = 0;
    const y1 = 1;
    const x2 = this._rect.width - 1;
    const y2 = 1;

    const color = [7, 8, 9, 5].includes( this._direction ) ? '#ff6600' : '#00FF00';

    this.bitmap.drawLine( x1, y1, x2, y2, color );

  }

//=============================================================================
  drawLeft()
  { // draw the left of the rectangle.
//=============================================================================

    const x1 = 1;
    const y1 = 0;
    const x2 = 1;
    const y2 = this._rect.height - 1;

    const color = [7, 4, 1, 5].includes( this._direction ) ? '#ff6600' : '#00FF00';

    this.bitmap.drawLine( x1, y1, x2, y2, color );

  }

//=============================================================================
  drawRight()
  { // draw the right of the rectangle.
//=============================================================================

    const x1 = this._rect.width - 1;
    const y1 = 0;
    const x2 = this._rect.width - 1;
    const y2 = this._rect.height;

    const color = [9, 6, 3, 5].includes( this._direction ) ? '#ff6600' : '#00FF00';

    this.bitmap.drawLine( x1, y1, x2, y2, color );

  }

//=============================================================================
  drawBottom()
  { // draw the bottom of the rectangle.
//=============================================================================

    const x1 = 0;
    const y1 = this._rect.height - 1;
    const x2 = this._rect.width;
    const y2 = this._rect.height - 1;

    const color = [1, 2, 3, 5].includes( this._direction ) ? '#ff6600' : '#00FF00';

    this.bitmap.drawLine( x1, y1, x2, y2, color );

  }


//=============================================================================
  update()
  { // update the rectangle.
//=============================================================================

    super.update();
    this.updateMouse();

  }

//=============================================================================
  getMouseCoord()
  { // return the moues coordinates scaled.
//=============================================================================

    const scale = this.parent.scale;
    const tx = Math.floor( ( TouchInput.x - this.parent.x ) / scale.x );
    const ty = Math.floor( ( TouchInput.y - this.parent.y ) / scale.y );

    return new Point( tx, ty );

  }

//=============================================================================
  getScaledRect()
  { // get the rectangle scaled.
//=============================================================================

    const scale = this.parent.scale;
    let { x, y, width, height } = this._rect;

    return new Rectangle( x, y, width, height );

  }

//=============================================================================
  mouseInBounds()
  { // return if the mouse is in boiunds.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    let { x, y, width, height } = this.getScaledRect();
    const p = 5 / this.parent.scale.x;
    x -= p;
    y -= p;
    width += p;
    height += p;

    return tx >= x && tx <= x + width && ty >= y && ty <= y + height;

  }

//=============================================================================
  updateMouse()
  { // update the mouse resizing the rectangle.
//=============================================================================

    if ( this.mouseInBounds() ) {
      this.updateHover();
    } else if ( this._direction ) {
      if ( !this._dragging ) {
        this._direction = 0;
        this.refresh();
      }
    }

    this.updateDrag();

  }

//=============================================================================
  getDirection( tx, ty )
  { // return the direction we can possibly scale the rect in.
//=============================================================================

    const scale = this.parent.scale;
    let { x, y, width, height } = this.getScaledRect();
    let centerX = tx - ( x + width / 2 );
    let centerY = ty - ( y + height / 2 );
    let distance = 5 / scale.x;
    let currentX = Infinity;
    let currentY = Infinity;
    let horz = 0;
    let vert = 0;

    if ( Input.isPressed( 'control' ) ) return 0;

    let top = Math.abs( ty - y );
    let left = Math.abs( tx - x );
    let right = Math.abs( tx - ( x + width ) );
    let bottom = Math.abs( ty - ( y + height ) );
    let center = Math.sqrt( centerX * centerX + centerY * centerY );

    if ( left <= distance && left < currentX ) {
      currentX = Math.abs( tx - x );
      horz = 4;
    }

    if ( right <= distance && right < currentX ) {
      currentX = Math.abs( tx - ( x + width ) );
      horz = 6;
    }

    if ( top <= distance && top < currentY ) {
      currentY = Math.abs( ty - y );
      vert = 8;
    }

    if ( bottom <= distance && bottom < currentY ) {
      currentY = Math.abs( ty - ( y + height ) );
      vert = 2;
    }

    if ( ( horz || vert ) && center < currentX && center < currentY ) {
      return 5;
    }

    if ( horz && vert ) {
      if ( horz == 4 && vert == 8 ) return 7;
      if ( horz == 4 && vert == 2 ) return 1;
      if ( horz == 6 && vert == 8 ) return 9;
      if ( horz == 6 && vert == 2 ) return 3;
    }

    return horz || vert || 5;

  }

//=============================================================================
  updateHover()
  { // update the edges of the hitbox.
//=============================================================================

    if ( !this._dragging ) {

      const { x:tx, y:ty } = this.getMouseCoord();
      const direction = this.getDirection( tx, ty );

      if ( this._direction != direction ) {
        this._direction = direction;
        this.refresh();
      }

      if ( this._direction && TouchInput.isTriggered() ) {
        this._orgRect = JsonEx.parse( JsonEx.stringify( this._rect ) );
        this._orgPos = new Point( tx, ty );
        this._dragging = true;
      }

    }

  }

//=============================================================================
  updateDrag()
  { // update hover over corners.
//=============================================================================

    if ( this._dragging ) {
      if ( !TouchInput.isPressed() ) return this._dragging = false;

      // TODO: add color of box depending on if hit or hurtbox
      if ( this._direction == 5 ) {
        this.dragCenter();

      } else if ( ( this._direction % 2 ) == 1 ) {
        this.dragEdges();

      } else {
        this.dragSides();
      }
      this.refresh();
    }

  }

//=============================================================================
  dragCenter()
  { // drag the sprite from the center.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const orgRect = this._orgRect;
    const orgPos = this._orgPos;
    const rect = this._rect;

    let ox = orgPos.x - orgRect.x;
    let oy = orgPos.y - orgRect.y;

    let dx = ( tx - orgRect.x );
    let dy = ( ty - orgRect.y );

    rect.x = orgRect.x + dx - ox;
    rect.y = orgRect.y + dy - oy;

  }

//=============================================================================
  dragEdges()
  { // draw the edges of the rectangle..
//=============================================================================

    switch ( this._direction ) {
      case 1:
        this.dragBottomLeft();
        break;
      case 3:
        this.dragBottomRight();
        break;
      case 7:
        this.dragTopLeft();
        break;
      case 9:
        this.dragTopRight();
        break;
    }

  }

//=============================================================================
  dragBottomLeft()
  { // dragging the rectangle from the bottom left corner.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let minH = org.height;
    let minW = org.width;

    let dx = tx - org.x;
    let dy = ty - org.y;

    rect.x = org.x + Math.ceil( Math.min( dx, minW ) );

    rect.width = minW + -Math.min( dx, minW );
    rect.height = Math.ceil( Math.max( dy, 1 ) );

    if ( dx >= minW - 1 && dy <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 9;
    } else if ( dx >= minW - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 3;
    } else if ( dy <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 7;
    }

  }

//=============================================================================
  dragBottomRight()
  { // drag the rectangle from the bottom right corner.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;

    let dx = tx - rect.x;
    let dy = ty - rect.y;

    rect.width = Math.ceil( Math.max( dx, 1 ) );
    rect.height = Math.ceil( Math.max( dy, 1 ) );

    if ( dx <= 0 && dy <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 7;
    } else if ( dx <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 1;
    } else if ( dy <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 9;
    }

  }

//=============================================================================
  dragTopLeft()
  { // drag the rectangle from the top left corner.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let minH = org.height;
    let minW = org.width;

    let dx = tx - org.x;
    let dy = ty - org.y;

    rect.x = org.x + Math.ceil( Math.min( dx, minW ) );
    rect.y = org.y + Math.ceil( Math.min( dy, minH ) );

    rect.width = minW + -Math.min( dx, minW );
    rect.height = minH + -Math.min( dy, minH );


    if ( dx >= minW - 1 && dy >= minH - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 3;
    } else if ( dx >= minW - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 9;
    } else if ( dy >= minH - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 1;
    }

  }

//=============================================================================
  dragTopRight()
  { // drag the rectangle from the top right corner.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let minH = org.height;

    let dx = tx - org.x;
    let dy = ty - org.y;

    rect.y = org.y + Math.ceil( Math.min( dy, minH ) );

    rect.width = Math.ceil( Math.max( dx, 1 ) );
    rect.height = minH + -Math.min( dy, minH );


    if ( dx <= 0 && dy >= minH - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 1;
    } else if ( dx <= 0 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 7;
    } else if ( dy >= minH - 1 ) {
      org.x = rect.x;
      org.y = rect.y;
      org.height = rect.height;
      org.width = rect.width;
      this._direction = 3;
    }

  }

//=============================================================================
  dragSides()
  { // drag the sides of the rectangle.
//=============================================================================

    switch ( this._direction ) {
      case 8:
        this.updateDragTop();
        break;
      case 6:
        this.updateDragRight();
        break;
      case 4:
        this.updateDragLeft();
        break;
      case 2:
        this.updateDragBottom();
        break;
    }

  }

//=============================================================================
  updateDragTop()
  { // update dragging the top of the rectangle.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let minH = org.height;

    let dy = ty - org.y;

    rect.y = org.y + Math.ceil( Math.min( dy, minH ) );
    rect.height = minH + -Math.min( dy, minH );

    if ( dy >= minH - 1 ) {
      org.y = rect.y;
      org.height = rect.height;
      this._direction = 2;
    }

  }

//=============================================================================
  updateDragRight()
  { // update dragging the right side of the rectangle.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let dx = tx - org.x;

    rect.width = Math.ceil( Math.max( dx, 1 ) );

    if ( dx <= 0 ) {
      org.x = rect.x;
      org.width = rect.width;
      this._direction = 4;
    }

  }

//=============================================================================
  updateDragLeft()
  { // update dragging the left side of the rectangle.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;
    let minW = org.width;

    let dx = tx - org.x;

    rect.x = org.x + Math.ceil( Math.min( dx, minW ) );

    rect.width = minW + -Math.min( dx, minW );


    if ( dx >= minW - 1 ) {
      org.x = rect.x;
      org.width = rect.width;
      this._direction = 6;
    }

  }

//=============================================================================
  updateDragBottom()
  { // update dragging the bottom of the rectangle.
//=============================================================================

    const { x:tx, y:ty } = this.getMouseCoord();
    const org = this._orgRect;
    const rect = this._rect;

    let dy = ty - org.y;

    rect.height = Math.max( dy, 1 );

    if ( dy <= 0 ) {
      org.y = rect.y;
      org.height = rect.height;
      this._direction = 8;
    }

  }

}
//=============================================================================
window.Sprite_Rectangle = Sprite_Rectangle;
//=============================================================================

//=============================================================================
// Sprite_Editor :
//=============================================================================

//=============================================================================
class Sprite_Editor extends Sprite
{ // Sprite_Editor

//=============================================================================
  constructor()
  { // Called on object creation.
//=============================================================================

    const width = Graphics.width / 2;
    const height = Graphics.height / 2;

    super( new Bitmap( width, height ) );

    this.createGrid();
    this.createSprite();
    this.createRectContainer();

    this._frameData = null;
    this._direction = 2;
    this._index = 0;
  }

//=============================================================================
  topLeft()
  { // return the top left position of this sprite.
//=============================================================================

    const x = this.x - this.width * this.scale.x * 0.5;
    const y = this.y - this.height * this.scale.y * 1.0;

    return new Point( x, y );

  }

//=============================================================================
  setTopLeft( x, y )
  { // set the position of the top left corner.
//=============================================================================

    x = Math.round( x + this.width * this.scale.x * 0.5 );
    y = Math.round( y + this.height * this.scale.y * 1.0 );

    this.x = x;
    this.y = y;

  }

//=============================================================================
  center()
  { // return the center of this sprite.
//=============================================================================

    const x = this.x;
    const y = this.y - this.height * this.scale.y * 0.5;

    return new Point( x, y );

  }

//=============================================================================
  centerAnchor()
  { // return the center anchor point.
//=============================================================================

    const origin = this.topLeft();
    const center = new Point( Graphics.width / 2, Graphics.height / 2 )
    const width = this.width * this.scale.x;
    const height = this.height * this.scale.y;
    const x = ( ( center.x - origin.x ) / width ).clamp( 0, 1 );
    const y = ( ( center.y - origin.y ) / height ).clamp( 0, 1 );

    return new Point( x, y );

  }

//=============================================================================
  zoomIn()
  { // zoom in the screen.
//=============================================================================

    const anchor = this.centerAnchor();
    const tl = this.topLeft();

    const w0 = this.width * anchor.x * this.scale.x;
    const h0 = this.height * anchor.y * this.scale.y;

    const px = tl.x + w0;
    const py = tl.y + h0;

    const scaleX = ( this.scale.x + 0.1 ).clamp( 0.5, 2 );
    const scaleY = ( this.scale.y + 0.1 ).clamp( 0.5, 2 );

    const w1 = this.width * anchor.x * scaleX;
    const h1 = this.height * anchor.y * scaleY;

    this.scale.x = scaleX;
    this.scale.y = scaleY;
    this.setTopLeft( px - w1, py - h1, anchor );

  }

//=============================================================================
  zoomOut()
  { // zoom in the screen.
//=============================================================================

    const anchor = this.centerAnchor();
    const tl = this.topLeft();

    const w0 = this.width * anchor.x * this.scale.x;
    const h0 = this.height * anchor.y * this.scale.y;

    const px = tl.x + w0;
    const py = tl.y + h0;

    const scaleX = ( this.scale.x - 0.1 ).clamp( 0.5, 2 );
    const scaleY = ( this.scale.y - 0.1 ).clamp( 0.5, 2 );

    const w1 = this.width * anchor.x * scaleX;
    const h1 = this.height * anchor.y * scaleY;

    this.scale.x = scaleX;
    this.scale.y = scaleY;

    this.setTopLeft( px - w1, py - h1, anchor );

  }

//=============================================================================
  createGrid()
  { // create a new grid.
//=============================================================================

    const width = Graphics.width / 2;
    const height = Graphics.height / 2;

    this._grid = new Sprite( new Bitmap( width, height ) );
    this._grid.anchor.set( 0.5, 1 );
    this.addChild( this._grid );
    this.refreshGrid();

  }

//=============================================================================
  refreshGrid()
  { // refresh the grid.
//=============================================================================

    const { width, height } = this._grid;

    this._grid.bitmap.drawLine( width / 2, 1, width / 2, height, 'white' );
    this._grid.bitmap.drawLine( 1, height / 2, width, height / 2, 'white' );
    this._grid.bitmap.drawLine( 1, 1, width, 1, 'white' );
    this._grid.bitmap.drawLine( 1, 1, 1, height, 'white' );
    this._grid.bitmap.drawLine( width - 1, 0, width - 1, height, 'white' );
    this._grid.bitmap.drawLine( 1, height -1, width, height -1, 'white' );

    if ( this._frameData ) {
      this._grid.bitmap.drawLine( 1, height -1, width, height -1, 'red' );

    }


  }

//=============================================================================
  createSprite()
  { // create the sprite for the characters frame.
//=============================================================================

    const width = Graphics.width / 2 - 4;
    const height = Graphics.height / 2 - 4;

    this._frameSprite = new Sprite( new Bitmap( width, height ) );
    this._frameSprite.position.set( -2, -2 );
    this._frameSprite.anchor.set( 0.5, 1 );
    this.addChild( this._frameSprite );

  }

//=============================================================================
  setFrameData( data )
  { // set the frame data.
//=============================================================================

    this._frameData = data;
    this._src = ImageManager.loadCharacter( data.filename );
    this.refreshFrameSprite();

  }

//=============================================================================
  setDirection( d )
  { // set the direction.
//=============================================================================

    this._direction = d;
    this.refreshFrameSprite();

  }

//=============================================================================
  setIndex( i )
  { // set the index to the value speicified.
//=============================================================================

    this._index = i;
    this.refreshFrameSprite();

  }

  //=============================================================================
    getFrameFor( src, index )
    { // return the frame for the bitmap.
  //=============================================================================

      const d = this._direction - ( ( this._direction || 0 ) >= 5 ? 2 : 1 );
      const w = src.width / this._frameData.frames;
      const h = src.height / 8;
      const x = w * ( index || 0 );
      const y = h * d;

      const rect = new Rectangle( x, y, w, h );
      rect.index = index + 1;

      return rect;

    }

//=============================================================================
  refreshFrameSprite()
  { // refresh the frame sprite.
//=============================================================================

    const bitmap = this._frameSprite.bitmap;

    bitmap.clear();
    this.refreshGrid();

    if ( this._src ) {
      this._src.addLoadListener( function() {
        const src = this._src;
        const rect = this.getFrameFor( this._src, this._index );
        const { x:sx, y:sy, width:sw, height:sh } = rect;
        const ratio = sw / sh;

        let dh = this._frameSprite.height;
        let dw = dh * ratio;
        let dx = ( this._frameSprite.width - dw ) / 2;
        let dy = 0;

        if ( dw > sw && dh > sh ) {
          bitmap.bltCrisp( src, sx, sy,sw, sh, dx, dy, dw, dh );

        } else {
          bitmap.blt( src, sx, sy,sw, sh, dx, dy, dw, dh );

        }
      }.bind( this ) );
    }

  }

//=============================================================================
  createRectContainer()
  { // create a new container for rectangle colliders.
//=============================================================================

    const width = Graphics.width / 2 - 4;
    const height = Graphics.height / 2 - 4;

    this._rectSprite = new Sprite( new Bitmap( width, height ) );
    this._rectSprite.position.set( -2, -2 );
    this._rectSprite.anchor.set( 0.5, 1 );
    this.addChild( this._rectSprite );
  }

//=============================================================================
  update()
  { // update the sprite.
//=============================================================================

    super.update();
    this.updateZoom();
    this.updateScroll();
    this.updateMouse();
  }

//=============================================================================
  updateZoom()
  { // update the zoom of the editor.
//=============================================================================

    const scroll = TouchInput.wheelY
    if ( scroll < 0 ) {
      this.zoomIn();

    } else if ( scroll > 0 ) {
      this.zoomOut();
    }

  }

//=============================================================================
  updateScroll()
  { // update the scroll of the editor.
//=============================================================================

    if ( Input.isPressed( 'up' ) ) {
      this.scrollUp();

    } else if ( Input.isPressed( 'down' ) ) {
      this.scrollDown();

    }

    if ( Input.isPressed( 'left' ) ) {
      this.scrollLeft();

    } else if ( Input.isPressed( 'right' ) ) {
      this.scrollRight();

    }

  }

//=============================================================================
  scrollUp()
  { // scroll up.
//=============================================================================

    const center = Graphics.height / 2;
    const min = center + 0;
    const max = center + this.height * this.scale.y;
    this.y = ( this.y + 10 ).clamp( min, max );

  }

//=============================================================================
  scrollDown()
  { // scroll down.
//=============================================================================

    const center = Graphics.height / 2;
    const min = center + 0;
    const max = center + this.height * this.scale.y;
    this.y = ( this.y - 10 ).clamp( min, max );

  }

//=============================================================================
  scrollLeft()
  { // scroll the editor to the left.
//=============================================================================

    const center = Graphics.width / 2;
    const min = center - this.width * this.scale.x * 0.5;
    const max = center + this.width * this.scale.x * 0.5;

    this.x = ( this.x + 10 ).clamp( min, max );

  }

//=============================================================================
  scrollRight()
  { // scroll the editor to the left.
//=============================================================================

    const center = Graphics.width / 2;
    const min = center - this.width * this.scale.x * 0.5;
    const max = center + this.width * this.scale.x * 0.5;

    this.x = ( this.x - 10 ).clamp( min, max );

  }

//=============================================================================
  mouseInBounds()
  { // return if the mouse is in boiunds of the editor area.
//=============================================================================

    const { x:tx, y:ty } = TouchInput;
    const x = Graphics.width / 4;
    const w = Graphics.width - x;
    const y = Graphics.height / 4;
    const h = Graphics.height - y;


    return tx > x && tx < w && ty > y && ty < h;

  }

//=============================================================================
  createRect()
  { // create a rectangle at the mouses position.
//=============================================================================

    const scale = this.scale;
    const x = Math.floor( ( TouchInput.x - this.x ) / scale.x );
    const y = Math.floor( ( TouchInput.y - this.y ) / scale.y );
    const width = 1;
    const height = 1;
    const rect = new Rectangle( x, y, width, height );

    this._currentRect = new Sprite_Rectangle( x, y );
    this._currentRect.refresh();

    this.addChild( this._currentRect );
  }

//=============================================================================
  isRectangleClicked()
  { // return if any rectangles are clicked.
//=============================================================================

    return this.children.some( sprite => sprite._dragging );

  }

//=============================================================================
  updateMouse()
  { // update the mouse clicking on the screen.
//=============================================================================

    if ( this.mouseInBounds() && TouchInput.isPressed() ) {

      if ( TouchInput.isTriggered() ) {
        if ( !this.isRectangleClicked() ) {
          this.createRect();
        }
      }

    }

  }

}

//=============================================================================
window.Sprite_Editor = Sprite_Editor;
//=============================================================================

( function ( $ ) { // CONFIG:

//=============================================================================
// Create functions specific for my code if it does not already exist!
// WARNING: DO NOT EDIT BELOW THIS LINE!!!
//=============================================================================

//-----------------------------------------------------------------------------
  Chaucer.parseArgs = Chaucer.parseArgs || function ( args )
  { // compare the current version with the target version.
//-----------------------------------------------------------------------------

    const obj = {};
    for ( var i = 0, l = args.length; i < l; i += 2 ) {
      obj[args[i]] = args[i + 1];
    }

    return obj;

  };

//-----------------------------------------------------------------------------
    Chaucer.compareVersion = Chaucer.compareVersion || function ( current, target )
    { // compare the current version with the target version.
//-----------------------------------------------------------------------------

      const v1 = current.split( '.' );
      const v2 = target.split( '.' );
      for ( let i = 0, l = v1.length; i < l; i++ ) {
        if ( v1[i] < v2[i] ) return -1; // version is lower!
        if ( v1[i] > v2[i] ) return 1; // version is higher!
      }
      return 0; // same version!

    };

//-----------------------------------------------------------------------------
    Chaucer.parse = Chaucer.parse || function( data )
    { // recursively parse any data passed in.
//-----------------------------------------------------------------------------
      try {
        data = JSON.parse( data );

      } catch ( err ) {
        data = data;

      } finally {

        if ( typeof data === 'object' ) {

          for ( const key in data ) {
            data[key] = Chaucer.parse( data[key] );
          };

        };

      };

      return data;

    };

//-----------------------------------------------------------------------------
    Chaucer.makePluginInfo = Chaucer.makePluginInfo || function ( $, n )
    { // Create plugin info for the object provided.
//-----------------------------------------------------------------------------

      for ( var i = 0, l = $plugins.length; i < l; i++ ) {

        if ( !$plugins[i].description.match( n ) ) continue;

        $.author = 'Chaucer';
        $.name = RegExp.$1;
        $.version = RegExp.$2;
        $.pluginName = $plugins[i].name;
        $.params = Chaucer.parse( $plugins[i].parameters );
        $.commands = {};
        $.alias = {};

      };

    };

  //============================================================================
    //Create plugin information.
  //============================================================================

    const identifier =  /(Character Editor Scene) : Version - (\d+.\d+.\d+)/;
    // $._nameError = 'Character Editor Scene was unable to load! Please revert any changes back to normal!';


    Chaucer.makePluginInfo( $, identifier );

    if ( !$.name ) throw new Error( $._nameError );

//=============================================================================

//-----------------------------------------------------------------------------
  $.registerPluginCommand = function ( command, fn )
  { // compare the current version with the target version.
//-----------------------------------------------------------------------------

  if ( Utils.RPGMAKER_NAME === 'MV' )
    $.commands[command] = fn;

  else if ( Utils.RPGMAKER_NAME === 'MZ' )
    PluginManager.registerCommand( $.pluginName, command, fn );

  };

 //-----------------------------------------------------------------------------
  $.alias = function ( className, method, fn, isStatic )
  { // use this method to quickly alias a method of a particular class.
//-----------------------------------------------------------------------------

    let key = `${className.name}.${( isStatic ? '' : 'prototype.' ) + method}`;
    let object = ( isStatic ? className : className.prototype );

    if ( $.alias[key] ) throw new Error( `${key} already aliased!` );

    $.alias[key] = object[method];

    let fnString = fn.toString();
    let instances = fnString.match( /\$.alias\((.*?)\)/g ) || [];

    for ( let i = 0, len = instances.length; i < len; i++ ) {

      let old = instances[i];
      let args = ['this'].concat( old.match( /\((.*?)\)/ )[1].split( ',' ) );
      args = args.filter( n => !!n );
      let next = `$.alias["${key}"].call(` + args.join( ',' ) + ')';

      fnString = fnString.replace( old, next );

    }

    eval( `${key} = ` + fnString );

  };

//-----------------------------------------------------------------------------
  $.expand = function ( className, method, fn, isStatic )
  { // use this method to quickly alias a method of a particular class.
//-----------------------------------------------------------------------------

    const obj = isStatic ? className : className.prototype;
    obj[method] = fn;

  };

//=============================================================================
  // MV SPECIFIC CODE :
//=============================================================================

    if ( Utils.RPGMAKER_NAME === 'MV' ) {

  //-----------------------------------------------------------------------------
    $.alias( Game_Interpreter, 'pluginCommand', function( command, args ) {
  //-----------------------------------------------------------------------------

        $.alias( command, args );

        command = command.toLowerCase();
        if ( $.commands[command] ) {
          $.commands[command].call( this, Chaucer.parseArgs( args ) );
        }
      } );

    }


//=============================================================================
// ALIASED CODE BELOW THIS LINE!
//=============================================================================

//=============================================================================
// ImageManager :
//=============================================================================

//-----------------------------------------------------------------------------
  $.alias( ImageManager, 'loadCharacter', function( url )
  { // Aliased loadTileset of class ImageManager.
//-----------------------------------------------------------------------------

    if ( !url ) return $.alias( url );

    const path = require( 'path' );
    const fs = require( 'fs' );
    const base = $gameTemp._project.directory;
    const file = path.join( base, 'img', 'characters', url + '.png' );

    let base64 = fs.readFileSync( file ).toString( 'base64' );
    base64 = 'data:image/png;base64,' + base64;

    return Bitmap.loadBase64( base64 );


  }, true );

//=============================================================================
// Sprite_Character :
//=============================================================================

//-----------------------------------------------------------------------------
  $.expand( Sprite_Character, 'isPlatformerSprite', function()
  { // return if the character is using 8 dir or not.
//-----------------------------------------------------------------------------

    const window = SceneManager._scene._directionsContainer;
    return window._usedir8 === 'platformer';

  }, false );

//-----------------------------------------------------------------------------
  $.expand( Sprite_Character, 'is8DirSprite', function()
  { // return if the character is using 8 dir or not.
//-----------------------------------------------------------------------------

    const window = SceneManager._scene._directionsContainer;
    return window._usedir8 === true;

  }, false );

//-----------------------------------------------------------------------------
  $.alias( Sprite_Character, 'characterPatternY', function()
  { // Aliased characterPatternY of class Sprite_Character.
//-----------------------------------------------------------------------------

    if ( this.isPlatformerSprite() ) {
      return 0;

    } else if ( this.is8DirSprite() ) {
      const d = this._character.direction();
      return d - ( d >= 5 ? 2 : 1 );

    } else {
      return $.alias();

    }

  }, false );

//-----------------------------------------------------------------------------
  $.alias( Sprite_Character, 'patternHeight', function()
  { // Aliased patternHeight of class Sprite_Character.
//-----------------------------------------------------------------------------

    if ( this.isPlatformerSprite() ) {
      return this.bitmap.height;

    } else if ( this.is8DirSprite() ) {
      return Math.floor( this.bitmap.height / 8 );

    } else {
      return $.alias();

    }

  }, false );

//=============================================================================
} )( Chaucer.characterEdit );
//=============================================================================
